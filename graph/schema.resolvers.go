package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"fmt"
	"log"

	"github.com/vaidik-bajpai/golang-graphql/database"
	"github.com/vaidik-bajpai/golang-graphql/graph/model"
	"github.com/vaidik-bajpai/golang-graphql/internal/prisma/db"
)

// CreateJobListing is the resolver for the createJobListing field.
func (r *mutationResolver) CreateJobListing(ctx context.Context, input model.CreateJobListingInput) (*model.JobListing, error) {
	jobListing, err := JobsModel.DB.JobListing.CreateOne(
		db.JobListing.Title.Set(input.Title),
		db.JobListing.Description.Set(input.Description),
		db.JobListing.Company.Set(input.Company),
		db.JobListing.URL.Set(input.URL),
	).Exec(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to create job listing: %w", err)
	}

	return &model.JobListing{
		ID:          jobListing.ID,
		Title:       jobListing.Title,
		Description: jobListing.Description,
		Company:     jobListing.Company,
		URL:         jobListing.URL,
	}, nil
}

// UpdateJobListing is the resolver for the updateJobListing field.
func (r *mutationResolver) UpdateJobListing(ctx context.Context, id int, input model.UpdateJobListingInput) (*model.JobListing, error) {
	updateParams := []db.JobListingSetParam{}
	if input.Title != nil {
		updateParams = append(updateParams, db.JobListing.Title.Set(*input.Title))
	}
	if input.Description != nil {
		updateParams = append(updateParams, db.JobListing.Description.Set(*input.Description))
	}
	if input.URL != nil {
		updateParams = append(updateParams, db.JobListing.URL.Set(*input.URL))
	}

	jobListing, err := JobsModel.DB.JobListing.FindUnique(
		db.JobListing.ID.Equals(id),
	).Update(
		updateParams...,
	).Exec(ctx)

	if err != nil {
		log.Fatal(err)
	}

	return &model.JobListing{
		ID:          jobListing.ID,
		Title:       jobListing.Title,
		Description: jobListing.Description,
		Company:     jobListing.Company,
		URL:         jobListing.URL,
	}, nil
}

// DeleteJobListing is the resolver for the deleteJobListing field.
func (r *mutationResolver) DeleteJobListing(ctx context.Context, id int) (*model.DeleteJobResponse, error) {
	_, err := JobsModel.DB.JobListing.FindUnique(
		db.JobListing.ID.Equals(id),
	).Delete().Exec(ctx)

	if err != nil {
		log.Fatal(err)
	}

	return &model.DeleteJobResponse{
		DeleteJobID: id,
	}, nil
}

// Jobs is the resolver for the jobs field.
func (r *queryResolver) Jobs(ctx context.Context) ([]*model.JobListing, error) {
	jobListings, err := JobsModel.DB.JobListing.FindMany().Exec(ctx)

	if err != nil {
		log.Fatal(err)
	}

	theJobListings := []*model.JobListing{}

	for _, jobListing := range jobListings {
		newJobListing := &model.JobListing{
			ID:          jobListing.ID,
			Title:       jobListing.Title,
			Company:     jobListing.Company,
			Description: jobListing.Description,
			URL:         jobListing.URL,
		}

		theJobListings = append(theJobListings, newJobListing)
	}

	return theJobListings, nil
}

// Job is the resolver for the job field.
func (r *queryResolver) Job(ctx context.Context, id int) (*model.JobListing, error) {
	jobListing, err := JobsModel.DB.JobListing.FindUnique(
		db.JobListing.ID.Equals(id),
	).Exec(ctx)

	if err != nil {
		log.Fatal(err)
	}

	return &model.JobListing{
		ID:          jobListing.ID,
		Title:       jobListing.Title,
		Company:     jobListing.Company,
		Description: jobListing.Description,
		URL:         jobListing.URL,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
var JobsModel = database.New()
